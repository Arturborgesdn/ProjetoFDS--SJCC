// ============================================
// CÓDIGO JAVASCRIPT: Integração Front-End com Back-End (Python/Flask)
// ============================================
// Autor: Assistente de IA (baseado no seu projeto SJCC)
// Conceito Geral: Este JS carrega quando a página abre, "escuta" cliques nos botões,
// envia uma mensagem para o Python via HTTP (fetch), recebe resposta e mostra um alerta.
// É assíncrono: Não trava a página enquanto "conversa" com o servidor.
// Aprendizado: JS roda no browser; Python no servidor. Eles se conectam via rede local.

// ============================================
// PASSO 1: ESPERAR A PÁGINA CARREGAR (DOM Ready)
// ============================================
// Conceito: 'DOMContentLoaded' é um evento do browser. Ele garante que o JS só rode
// DEPOIS que o HTML/CSS carregou (DOM = Document Object Model, a estrutura da página).
// Sem isso, o JS pode tentar achar botões que ainda não existem.
document.addEventListener('DOMContentLoaded', function() {
    
    // ============================================
    // PASSO 2: SELECIONAR OS ELEMENTOS DO HTML
    // ============================================
    // Conceito: 'querySelector' busca um elemento pelo seletor CSS (como classes ou IDs).
    // Retorna o primeiro que acha. Se não achar, retorna 'null' (use 'if' para checar).
    // Aqui: Pegamos os botões pelo nome da classe (do seu HTML).
    const btnComoGastar = document.querySelector('.jcpoints');  // Botão "COMO GASTAR?"
    const lupaBtn = document.querySelector('.lupa-btn');        // Ícone da lupa (busca)
    
    // ============================================
    // PASSO 3: CONFIGURAÇÃO DA CONEXÃO COM PYTHON
    // ============================================
    // Conceito: 'const' declara uma variável que não muda (boa prática para URLs fixas).
    // API_URL: Endereço do servidor Python (localhost = sua máquina, porta 5000 = do Flask).
    // No futuro, mude para um domínio real (ex: 'https://meusite.com/api').
    const API_URL = 'http://localhost:5000/api/conectar';
    
    // ============================================
    // PASSO 4: FUNÇÃO PARA CONECTAR COM PYTHON (Fetch Assíncrono)
    // ============================================
    // Conceito: 'function' cria uma função reutilizável. 'fetch()' é uma API nativa do JS
    // para fazer requisições HTTP (como POST para enviar dados). É PROMISE-based (assíncrono):
    // - Envia a requisição.
    // - .then(): Roda se sucesso (recebe resposta).
    // - .catch(): Roda se erro (ex: servidor off).
    // Aqui: Enviamos JSON (formato de dados leve) com a 'acao' para identificar o clique.
    function testarConexao(acao) {
        // Log para debug: 'console.log' mostra mensagens no Console (F12). Útil para aprender!
        // Conceito: Ajuda a rastrear o que o JS está fazendo (sem afetar o usuário).
        console.log('Tentando conectar com Python para ação:', acao);
        
        // Fetch: Envia POST para a URL.
        fetch(API_URL, {
            method: 'POST',  // Método HTTP: POST para enviar dados (GET é só ler).
            headers: {       // Headers: Metadados da requisição (como "tipo de conteúdo").
                'Content-Type': 'application/json'  // Diz que o body é JSON.
            },
            body: JSON.stringify({  // Body: Os dados enviados. 'JSON.stringify' converte objeto JS em string JSON.
                acao: acao  // Objeto simples: { acao: 'gastar' } — Python lê isso com request.get_json().
            })
        })
        .then(function(response) {  // .then(1): Recebe a resposta HTTP (objeto Response).
            // Conceito: Verifica se o status é OK (200-299). Se não, pode ser erro no servidor.
            if (!response.ok) {
                throw new Error('Resposta do servidor não OK: ' + response.status);
            }
            return response.json();  // Converte o body da resposta em objeto JS (JSON.parse automático).
        })
        .then(function(data) {  // .then(2): Agora 'data' é o JSON do Python (ex: {sucesso: true, mensagem: '...'}).
            if (data.sucesso) {
                // Sucesso: Log e chama a função de alerta.
                console.log('Conexão com Python OK:', data.mensagem);
                alertOriginal(acao);  // Chama função abaixo para mostrar o alerta.
            } else {
                // Erro na lógica do Python (raro).
                console.log('Erro na resposta do Python:', data.mensagem);
                alertOriginal(acao);  // Fallback: Mostra alerta mesmo assim.
            }
        })
        .catch(function(error) {  // .catch: Captura qualquer erro (rede, JSON inválido, etc.).
            // Conceito: 'console.error' destaca em vermelho no Console. Útil para debug.
            console.error('Falha na conexão com Python:', error);
            // Fallback: Se Python off, ainda mostra o alerta (não quebra o app).
            alertOriginal(acao);
        });
    }
    
    // ============================================
    // PASSO 5: FUNÇÃO PARA OS ALERTAS (Placeholders)
    // ============================================
    // Conceito: Função simples para centralizar os alertas. 'if/else' verifica condições.
    // 'alert()' é nativo do browser: Mostra pop-up (básico, mas bom para MVP).
    // No futuro: Substitua por modais customizados (ex: com HTML/CSS).
    function alertOriginal(acao) {
        if (acao === 'gastar') {
            alert('Calma! jaja incluiremos essa pagina no MVP');
        } else if (acao === 'busca') {
            alert('Ainda estamos implementando isso espera mais um pouco');
        } else {
            alert('Ação desconhecida: ' + acao);  // Novo: Para ações extras no futuro.
        }
    }

    // ============================================
    // PASSO 6: ESCUTAR OS CLIQUES (Event Listeners)
    // ============================================
    // Conceito: 'addEventListener' "escuta" eventos (como 'click'). Roda uma função quando acontece.
    // 'event.preventDefault()': Impede o comportamento padrão (ex: não recarrega a página se for link).
    // 'if (elemento)': Checa se o querySelector achou algo (evita erros se botão não existir).
    
    if (btnComoGastar) {  // Checa se o botão existe.
        btnComoGastar.addEventListener('click', function(event) {
            event.preventDefault();  // Impede default (se for <a> ou form).
            // Chama a função de conexão: Passa 'gastar' como parâmetro.
            testarConexao('gastar');
        });
    } else {
        console.warn('Botão .jcpoints não encontrado! Verifique o HTML.');  // Debug se faltar.
    }

    if (lupaBtn) {
        lupaBtn.addEventListener('click', function(event) {
            event.preventDefault();
            testarConexao('busca');
        });
    } else {
        console.warn('Botão .lupa-btn não encontrado! Verifique o HTML.');
    }

    // ============================================
    // PASSO 7: CONFIRMAÇÃO FINAL (Log de Inicialização)
    // ============================================
    // Conceito: Log ao final para saber que tudo carregou OK. Bom para debug inicial.
    console.log('JS atualizado: Pronto para conectar com Python!');
    console.log('Botões encontrados:', { gastar: !!btnComoGastar, busca: !!lupaBtn });  // !! converte para true/false.
});
